#TransportCatalogue
TransportCatalogue работает в два этапа: 
1. Установка основных параметров, создание базы маршрутов, постоение графа и сериализация в файл. 
2. Десериализация базы из файла и работа с запросами разных видов:
    - Получение информации о маршруте.
    - Получение информации об остановке.
    - Получение изображения маршрутов.
    - Поиск оптимального маршрута между двумя остановками с учетом времени ожидания транспорта.

Программа работает с потоками ввода-вывода в формате JSON-объекта.
---
##Минимальные требования
1. Стандарт языка С++17.
2. Protobuf 3.21.12. Код доступен по ссылке [https://github.com/protocolbuffers/protobuf/releases/tag/v21.12](https://github.com/protocolbuffers/protobuf/releases/tag/v21.12)
     Выберите архив protobuf-cpp и распакуйте его на своём компьютере.
3. Cmake 3.10.
4. Для Windows используйте MinGW. 
---
##Сборка Protobuf
1. Создать папку, в которой разместится пакет Protobuf.
2. Выполнить следующие команды
\```
cmake <путь к распакованному архиву>/protobuf-3.21.12  \
      -DCMAKE_BUILD_TYPE=Debug                         \
      -Dprotobuf_BUILD_TESTS=OFF                       \
      -DCMAKE_INSTALL_PREFIX=<путь к месту установки пакета>/Protobuf
cmake --build .
cmake --install .
\```
---
##Сборка программы
1. В файле CMakeLists.txt замените пути (указаны внутри кавычек) на актуальные для вас в строках `set(CMAKE_PREFIX_PATH "F:/Protobuf/build-debug/Protobuf")` и `include_directories("F:/Protobuf/build-debug/Protobuf/include")`.
2. Создайте папку build.
3. Внутри папки build выполните следующие команды
\```
cmake ../ -G "MinGW Makefiles"
cmake --build .
\```
---
##Запуск программы
Пример запуска для заполнения базы:
\```
transport_catalogue.exe make_base <base.json
\```
Пример запуска для выполнения запросов к базе:
\```
transport_catalogue.exe process_requests <req.json >out.txt
\```
---
##Формат входных и выходных данных
###Программа make_base
На вход программе make_base через стандартный поток ввода подаётся JSON со следующими ключами:
1. `base_requests`: запросы Bus и Stop на создание базы.
    **Пример** 
\```
"base_requests": [
          {
              "is_roundtrip": true,
              "name": "297",
              "stops": [
                  "Biryulyovo Zapadnoye",
                  "Biryulyovo Tovarnaya",
                  "Universam",
                  "Biryulyovo Zapadnoye"
              ],
              "type": "Bus"
          },          
          {
              "latitude": 55.574371,
              "longitude": 37.6517,
              "name": "Biryulyovo Zapadnoye",
              "road_distances": {
                  "Biryulyovo Tovarnaya": 2600
              },
              "type": "Stop"
          }          
      ]
\```
где
- `is_roundtrip` — значение типа bool, указывает, кольцевой маршрут или нет;
- `name` — название маршрута или остановки;
- `stops` — массив с названиями остановок, из которых состоит автобусный маршрут. У кольцевого маршрута название первой и последней остановки совпадают;
- `type` — тип запроса. Указывает на создание маршрута (Bus) или остановки (Stop);
- `latitude` и `longitude` задают координаты широты и долготы остановки;
- `road_distances` — словарь, задающий расстояние до соседних остановок. Ключ — название остановки, значение — целое число в метрах.

2. `routing_settings`: настройки маршрутизации.
    **Пример** 
\```
"routing_settings": {
          "bus_wait_time": 2,
          "bus_velocity": 30
      }
\```
где
- `bus_wait_time` — время ожидания автобуса на остановке, в минутах. Считайте, что когда бы человек ни пришёл на остановку и какой бы ни была эта остановка, он будет ждать любой автобус в точности указанное количество минут. Значение — целое число от 1 до 1000.
- `bus_velocity` — скорость автобуса, в км/ч. Считайте, что скорость любого автобуса постоянна и в точности равна указанному числу. Время стоянки на остановках не учитывается, время разгона и торможения тоже. Значение — вещественное число от 1 до 1000.
Данная конфигурация задаёт время ожидания, равным 2 минутам, и скорость автобусов, равной 30 километрам в час.

3. `render_settings`: настройки отрисовки.
**Пример** 
\```
"render_settings": {
          "width": 1200,
          "height": 500,
          "padding": 50,
          "stop_radius": 5,
          "line_width": 14,
          "bus_label_font_size": 20,
          "bus_label_offset": [
              7,
              15
          ],
          "stop_label_font_size": 18,
          "stop_label_offset": [
              7,
              -3
          ],
          "underlayer_color": [
              255,
              255,
              255,
              0.85
          ],
          "underlayer_width": 3,
          "color_palette": [
              "green",
              [
                  255,
                  160,
                  0
              ],
              "red"
          ]
\```
где
- `width` и `height` — ширина и высота изображения в пикселях. Вещественное число в диапазоне от 0 до 100000.
- `padding` — отступ краёв карты от границ SVG-документа. Вещественное число не меньше 0 и меньше `min(width, height)/2`.
- `line_width` — толщина линий, которыми рисуются автобусные маршруты. Вещественное число в диапазоне от 0 до 100000.
- `stop_radius` — радиус окружностей, которыми обозначаются остановки. Вещественное число в диапазоне от 0 до 100000.
- `bus_label_font_size` — размер текста, которым написаны названия автобусных маршрутов. Целое число в диапазоне от 0 до 100000.
- `bus_label_offset` — смещение надписи с названием маршрута относительно координат конечной остановки на карте. Массив из двух элементов типа double. Задаёт значения свойств dx и dy SVG-элемента <text>. Элементы массива — числа в диапазоне от –100000 до 100000.
- `stop_label_font_size` — размер текста, которым отображаются названия остановок. Целое число в диапазоне от 0 до 100000.
- `stop_label_offset` — смещение названия остановки относительно её координат на карте. Массив из двух элементов типа double. Задаёт значения свойств dx и dy SVG-элемента `<text>`. Числа в диапазоне от –100000 до 100000.
- `underlayer_color` — цвет подложки под названиями остановок и маршрутов. Формат хранения цвета будет ниже.
- `underlayer_width` — толщина подложки под названиями остановок и маршрутов. Задаёт значение атрибута stroke-width элемента <text>. Вещественное число в диапазоне от 0 до 100000.
- `color_palette` — цветовая палитра. Непустой массив.

Цвет можно указать в одном из следующих форматов:
- в виде строки, например, `"red"` или `"black"`;
- в массиве из трёх целых чисел диапазона [0, 255];
- в массиве из четырёх элементов: три целых числа в диапазоне от [0, 255] и одно вещественное число в диапазоне от [0.0, 1.0]. Они задают составляющие `red`, `green`, `blue` и `opacity` цвета;

4. `serialization_settings`: настройки сериализации. 
    **Пример** 
\```
"serialization_settings": {
          "file": "transport_catalogue.db"
      }
\```
где
- `file` — название файла, из которого нужно считать сериализованную базу.

###Программа process_requests
На вход программе process_requests подаётся файл с сериализованной базой (результат работы make_base), а также — через стандартный поток ввода — JSON со следующими ключами:
1. `stat_requests`: запросы к готовой базе. У каждого запроса есть свой `id`.
2. `serialization_settings`: настройки сериализации в формате, аналогичном этой же секции на входе make_base. А именно, в ключе file указывается название файла, из которого нужно считать сериализованную базу.

####Пример запроса информации о маршруте и ответа на него
Запрос
\```
{
    "id": 1,
    "name": "297",
    "type": "Bus"
}
\```
Ответ
\```
{
    "curvature": 1.42963,
    "request_id": 1,
    "route_length": 5990,
    "stop_count": 4,
    "unique_stop_count": 3
}
\```
где 
- `curvature` — число типа double, отражающее извилистость маршрута. Извилистость равна отношению длины дорожного расстояния маршрута к длине географического расстояния;
- `route_length` — целое число, равное длине маршрута в метрах;
- `stop_count` — количество остановок на маршруте;
- `unique_stop_count` — количество уникальных остановок на маршруте;

####Пример запроса информации об остановке и ответа на него
Запрос
\```
{
    "id": 3,
    "name": "Universam",
    "type": "Stop"
}
\```
Ответ
\```
{
    "buses": [
        "297",
        "635"
    ],
    "request_id": 3
}
\```
где 
- `buses` — названия автобусных маршрутов, проходящих через эту остановку;

####Пример запроса на отрисовку карты и ответа на него
Запрос
\```
{
    "id": 1359372752,
    "type": "Map"
}
\```
Ответ
\```
{
  "map": "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">...\n</svg>",
  "request_id": 1359372752
}
\```
где 
- `map` —  строка с изображением карты в формате SVG;

####Пример запроса на построение маршрута и ответа на него
Запрос
\```
{
    "type": "Route",
    "from": "Biryulyovo Zapadnoye",
    "to": "Universam",
    "id": 4
}
\```
где 
- `from` —  остановка, с которой начинается маршрут;
- `to` —  остановка, на которой заканчивается маршрут;

Ответ
\```
{
    "items": [
        {
            "stop_name": "Biryulyovo Zapadnoye",
            "time": 6,
            "type": "Wait"
        },
        {
            "bus": "297",
            "span_count": 2,
            "time": 5.235,
            "type": "Bus"
        },
        {
            "stop_name": "Universam",
            "time": 6,
            "type": "Wait"
        },
        {
            "bus": "635",
            "span_count": 1,
            "time": 6.975,
            "type": "Bus"
        }
    ],
    "request_id": 5,
    "total_time": 24.21
}
\```
где 
- `total_time` —  суммарное время в минутах, которое требуется для прохождения маршрута, выведенное в виде вещественного числа;
- `items` —  список элементов маршрута, каждый из которых описывает непрерывную активность пассажира, требующую временных затрат. А именно элементы маршрута бывают двух типов:
    1. `Wait` — подождать нужное количество минут (в нашем случае всегда `bus_wait_time`) на указанной остановке;
    2. `Bus` — проехать `span_count` остановок (перегонов между остановками) на автобусе `bus`, потратив указанное количество минут.



